LINKED LIST
• linear data structure in which the elements (nodes) are scattered in memory
• node has 2 things: 1. the data it stores 2. pointer to the next node 
    • each node knows the address of its successor
• last node’s next pointer points to NULL
• the entry point (head) is not a node itself, it holds the address of the first node; if empty linked list head pointer points to NULL

• size of the array is fixed sized of linked list is not fixed
• requires more space 
• must traverse list from the start
• no shifting, and deleting is easy (kind of)

Node struct & create_node (one isolated node)
    typedef struct node_ { //a node has 2 things
      char data; // could be any type
      struct node_ * next; // pointer to next node (self referential)
    } Node;
    Node * create_node(char ch) { //take a char and creates a node and returns address of the node
    Node * node = (Node *) malloc(sizeof(Node)); //dynamic allocation for each node
    assert(node); //
    node->data = ch;
    node->next = NULL;
    return node;
    }

print - output all data items in order from head to tail
  • void print(const Node * head)
      • use a Node pointer named cur to advance node by node through list, each time cur encounters another node, output that node’s data value

length - reports number of items currently in list
    • long length(const Node * head)
        • simliar to print, instead of printer, just adds 1 to count per advance

add_after - insert new node with a given data value immediately after a given existing node
    • void add_after(Node * node, char val) // 2 inputs 
        • val paramater - data value to place in new node
        • node parameter - holds address of existing node where new node should be placed right after (parent of new child node)
        • new node needs to be dynamically allocated
        • additional statements are needed to adjust links appropriately so list stays connected


Day 18 MORE ON LINKED LIST
• Pointer are pass by value
• The linked list head should be passed by reference if it needs to be updated (below functions must have address of the head --> double pointer **)
• the address of a pointer is a double pointer
            void fun1(int ** ip) {
            *ip += 1; // increment the address by 4 bytes (bc its a int)
            }

Other good ones:
• clear - deallocates all nodes in the list, sets head pointer to null
• add_front --> void add_front(Node ** list_ptr, char val); (** bc it messes with head, unlike add_after that never messes with head)
        void add_front(Node ** list_ptr, char val) { //(address of head and value as parameter)
        Node * new = create_node(val);
        new->next = *list_ptr; //new node's next gets address of old first node
        *list_ptr = new;
• clear_list (free all nodes)
• remove_after --> char remove_after(Node * node);
• remove_front --> char remove_front(Node ** list_ptr);
• remove_all (remove all occurrences of a particular data value)












